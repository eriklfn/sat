/**
 * Este arquivo deve ser inserido no sub-diretorio 'node_modules'
 * do diretorio que voce esta executando.
 * 
 * Escrito por Erike Nascimento em November/2018;
 * Baseado no modelo de Fernando Castor de Novembro/2017.
 */
exports.solve = function (fileName) {
    let formula = readFormula(fileName)
    let result = doSolve(formula.clauses, formula.variables)
    return result // Dois campos: isSat e satisfyingAssignment.
}

// Recebe a tarefa atual e devolve a proxima.
function nextAssignment(currentAssignment) {
    let i = currentAssignment.lenght - 1; // contador
    // implementado aqui o codigo para produzir a proxima tarefa
    // baseada no 'currentAssignment'.
    while (i >= 0) {
        // checa se a ultima variavel é false, se for torna a
        // true e sai do lao while.
        if (currentAssignment[i] == false) {
            currentAssignment[i] = true;
            return currentAssignment;
        }
        else {
            // caso nao seja, transforma em false e analisa o
            // elemento anterior.
            currentAssignment[i] = false;
            i--;
        }
    }
    return currentAssignment;
}

function doSolve(clauses, assignment) {
    let isSat = false;
    let i = 0;
    // laço enquanto nao for satisfativel nem tiver alcancado
    // a ultima tarfeta.
    while ((isSat == false) && (i < Math.pow(2, assignment.length))) {
        for (let i = 0; i < clauses.length; i++) {
            for (let j = 0; j < clauses[i].length; j++) {
                // verifica se tarefa satisfaz a formula, caso sim
                // isSat se torna true. 
                if (clauses[i][j] == true) {
                    isSat = true;
                }
            }
        }
        // abaixo indica que nao foi satisfativel, mas ainda esta dentro
        // do limte, entao chama a proxima tarefa e atribui mais 1 ao contador.
        assignment = nextAssignment(assignment);
        i++;
    }
    let result = { 'isSat': isSat, satisfyingAssignment: null }
    // caso seja satisfativel ira guardar o valor da variavel. caso
    // nao, retornara o padrão 'null'.
    if (isSat == true) {
        result.satisfyingAssignment = assignment
    }
    return result
}

function readFormula(fileName) {

    // Para ler o arquivo, e possível usar o modulo 'fs'.
    var fs = require('fs');

    // Use a funcao readFileSync ao inves de readFile.
    let lerarquivo = fs.readFileSync(fileName).toString();
    let text = lerarquivo.split("/[\r\n]+/");

    // Primeiro, le as linhas de texto do arquivo e so depois 
    // usa as funcoes auxiliares.
    let clauses = readClauses(text);
    let variables = readVariables(clauses);

    // Na linha seguinte, leitor e transmitido como um argumento
    // para que a funcao seja capaz de extrair a especificacao
    // do problema.
    let specOk = checkProblemSpecification(text, clauses, variables)

    let result = { 'clauses': [], 'variables': [] }
    if (specOk) {
        result.clauses = clauses
        result.variables = variables
    }
    return result
}

//extrai as clausulas do arquivo e produz um array
function readClauses(text) {
    let clauses = [];
    let clausesTemp = [];

    // examina as posicoes do array
    for (let i = 0; i < text.length; i++) {
        // caso seja um comentario ou pergunta ira ignorar 
        // o passo abaixo.
        if (text[i].charAt(0) != 'c'
            && text[i].charAt(0) != 'p') {
            //se a condicao for verdadeira, vai guardar os valores
            // no vetor e remover o 0 no final.
            clausesTemp[i] = text[i].replace(" 0", "");
            // manda o valores para o vetor separando os pelo espaço
            // formando assim uma matriz.
            clauses.push(clausesTemp[i]).split(" ");
        }
    }
    return clauses;
}

// processa as clausulas e identifica todas as variaveis
// e produz como resultado um array.
function readVariables(clauses) {
    let bidimensional = []; // para acessar os valores 2d.
    let absl = [] // para armazenar o valor absoluto.
    let unique = "" //armazena variaveis unicas.
    //percorrre a matriz.
    for (let i = 0; i < clauses.length; i++) {
        bidimensional = clauses[i];
        for (let j = 0; j < clauses.length; j++) {
            absl = Math.abs(bidimensional[j]);
            if (!unique.contains(absl)) {
                unique += absl + " ";
            }
        }
    }
    unique = unique.split(" ");
    let tamanho = unique.length;
    let variables = []
    for (let i = 0; i < tamanho; i++) {
        variables[i] = false;
    }
    return variables;
}

// checa se as clausulas e variaveis batem com a linha de problema
function checkProblemSpecification(text, clauses, variables) {
    let linhaEncontrada = [];
    let terminaLaco = false;
    let contador = 0;

    // percorre o texto.
    while (contador < text.length && terminaLaco == false) {
        // busca a linha da pegunta que contem 'p';
        if (text[i].charAt(0) == 'p') {
            linhaEncontrada = text[i].split(" ");
            terminaLaco = true;
        }
        contador++;
    }

    // com a  linha encontrada, o programa ira atribuir cada valor
    // a sua respectiva variavael.
    let numeroVariaveis = linhaEncontrada[2];
    let numeroClausulas = linhaEncontrada[3];

    // checa se a especificacao e compativel com os dados guardados
    if (variables.length == numeroVariaveis &&
        clauses.length == numeroClausulas) {
        return true;
    }
    else {
        return false;
    }
}