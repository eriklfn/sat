/**
 * Este arquivo deve ser inserido no sub-diretorio 'node_modules'
 * do diretorio que voce esta executando.
 * 
 * Escrito por Erike Nascimento em November/2018;
 * Baseado no modelo de Fernando Castor de Novembro/2017.
 */
exports.solve = function (fileName) {
    let formula = readFormula(fileName);
    let result = doSolve(formula.clauses, formula.variables);
    return result; // Dois campos: isSat e satisfyingAssignment.
}

// Recebe a tarefa atual e devolve a proxima.
function nextAssignment(currentAssignment) {

    let nextAssignment = currentAssignment; // separa para o retorno.
    let i = currentAssignment.length - 1; // contador

    // implementado aqui o codigo para produzir a proxima tarefa
    // baseada no 'currentAssignment'.
    while (i >= 0) {

        // checa se a ultima variavel é false, se for torna a
        // true e sai do laco while.
        if (currentAssignment[i] == false) {
            currentAssignment[i] = true;
            //funcao recusiva funcionara como um break;
            return nextAssignment(curentAssignment);
        }

        // caso nao seja, transforma em false e analisa o
        // elemento anterior.
        else {

            currentAssignment[i] = false;
            i--; // contador para anlisar o valor mais a esquerda
        }
    }
    return nextAssignment;
}

function doSolve(clauses, assignment) {

    let isSat = false;
    let cont = 0; // contador.

    // laço enquanto nao for satisfativel nem tiver alcancado
    // a ultima tarfeta.
    while ((isSat == false) && (cont < Math.pow(2, assignment.length))) {

        // dois lacos for para preencher as duas dimensoes da matriz
        for (let i = 0; i < clauses.length && isSat == false; i++) {
            for (let j = 0; j < clauses[i].length && isSat == false; j++) {

                // verifica se tarefa satisfaz a formula, se o valor da clauses for
                // maior do que zero, o boolean do assignment deve ser true, mas se o valor
                // clauses for menor que zero o assignment deve ser false.
                //caso sim isSat se torna true. 
                if ((clauses[i][j] > 0 && assignment[j] == true) ||
                    (clauses[i][j] < 0 && assignment[j] == false)) {
                    isSat = true;

                }
                // abaixo indica que nao foi satisfativel, mas ainda esta dentro
                // do limte, entao chama a proxima tarefa e atribui mais 1 ao contador.
                else {
                    assignment = nextAssignment(assignment);
                    cont++;
                }
            }
        }
    }
    let result = { 'isSat': isSat, satisfyingAssignment: null }

    // caso seja satisfativel ira guardar o valor da variavel. caso
    // nao, retornara o padrão 'null'.
    if (isSat == true) {
        result.satisfyingAssignment = assignment;
    }
    return result;
}

function readFormula(fileName) {

    // Para ler o arquivo, e possível usar o modulo 'fs'.
    var fs = require('fs');

    // Use a funcao readFileSync ao inves de readFile.
    let lerarquivo = fs.readFileSync(fileName).toString();

    // split retirara a quebra de linha do codigo
    let text = lerarquivo.split("/[\r\n]+/");

    // Primeiro, le as linhas de texto do arquivo e so depois 
    // usa as funcoes auxiliares.
    let clauses = readClauses(text);
    let variables = readVariables(clauses);

    // Na linha seguinte, leitor e transmitido como um argumento
    // para que a funcao seja capaz de extrair a especificacao
    // do problema.
    let specOk = checkProblemSpecification(text, clauses, variables);

    let result = { 'clauses': [], 'variables': [] }
    if (specOk) {
        result.clauses = clauses;
        result.variables = variables;
    }
    return result;
}

//extrai as clausulas do arquivo e produz um array
function readClauses(text) {
    let clauses = [];
    let clausesTemp = [];

    // examina as posicoes do array
    for (let i = 0; i < text.length; i++) {

        // caso seja um comentario ou pergunta ira ignorar 
        // o passo abaixo.
        if (text[i].charAt(0) != 'c'
            && text[i].charAt(0) != 'p') {

            //se a condicao for verdadeira, vai guardar os valores
            // no vetor e remover o 0 no final.
            clausesTemp[i] = text[i].replace(" 0", "");

            // manda o valores para o vetor separando os pelo espaço
            // formando assim uma matriz.
            clauses.push(clausesTemp[i]).split(" ");
        }
    }
    return clauses;
}

// processa as clausulas e identifica todas as variaveis
// e produz como resultado um array.
function readVariables(clauses) {

    let bidimensional = []; // para acessar os valores 2d.
    let absl = []; // para armazenar o valor absoluto.
    let unique = ""; //armazena variaveis unicas.
    //percorrre a matriz.
    for (let i = 0; i < clauses.length; i++) {

        // a variavel bidimensional recebera a string contida
        //dentro da atual clauses analisada.
        bidimensional = clauses[i];
        for (let j = 0; j < bidimensional.length; j++) {

            // ja que nao importa se a variavel estara negada ou
            // nao para ser unica, salva seu valor absoluto.
            absl = Math.abs(bidimensional[j]);
            if (!unique.contains(absl)) {

                // sera salvo numa string chamada unique que
                // adicionara um espaço para separar cada uma.
                unique += absl + " ";
            }
        }
    }

    // agora vai usar o split para separar os elementos de unique
    // como elementos de uma matriz tamanho n.
    unique = unique.split(" ");
    let variables = [];

    //preenchera a matriz de tamanho n com valores bool: false.
    for (let i = 0; i < unique.length; i++) {
        variables[i] = false;
    }
    return variables;
}

// checa se as clausulas e variaveis batem com a linha de problema
function checkProblemSpecification(text, clauses, variables) {
    let linhaEncontrada = [];
    let encontrouLinha = false; // identifica a linha que contem p.
    let contador = 0;

    // percorre o texto.
    while (contador < text.length && encontrouLinha == false) {

        // busca a linha da pegunta que contem 'p';
        if (text[i].charAt(0) == 'p') {
            linhaEncontrada = text[i].split(" ");
            encontrouLinha = true;
        }
        contador++;
    }

    // se chegar ate aqui, quer dizer que o contador ja excede o tamanho do texto e
    // ainda nao foi encontrada a linha do problema, ou seja, ela não existe, portanto
    // a condicao pro while n existira mais, dai o programa seguira em frente.
    if (encontrouLinha == false) {
        return false;
    }

    // com a  linha encontrada, o programa ira atribuir cada valor
    // a sua respectiva variavael.
    let numeroVariaveis = linhaEncontrada[2];
    let numeroClausulas = linhaEncontrada[3];

    // checa se a especificacao e compativel com os dados guardados
    if (variables.length == numeroVariaveis &&
        clauses.length == numeroClausulas) {
        return true;
    }
    else {
        return false;
    }
}